code source: https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a01052_source.html
rb tree: https://www.programiz.com/dsa/red-black-tree
	details -> delete node: https://www.programiz.com/dsa/deletion-from-a-red-black-tree
			-> insert node: https://www.programiz.com/dsa/insertion-in-a-red-black-tree
rb iterator: https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a01067_source.html

-	allocate pas la bonne capacity
	push back -> multiple
	insert -> size() + n
	resize -> n
	reserve -> n
	asign -> n
-	constructeur map
-	rend et rbegin doit segfault quand map empty
-	conditionnal jump quand erase et devient empty
-	ite_n1 -> init d'un map iterator avec const iterator doit pas marcher mais marche en se faisant passer pour un node *

what i was doing: insert position

mazoise vector :
	dans reserve, 	si - de 2x plus grand que la taille deja allouee alors multiplier la taille par 2 
							| sauf si n est < a la size multipliee par deux ou capacity == 0 > alors allouer n
					si n est plus de 2x plus grand que la taille deja allouee, allouer n

	dans resize		/** si n < 2*size && < 2*capacity(), alors size()*2 **/
					/** si n < 2*taille allouee mais >  **/
					int    new_allocate_size;// = (m_alloc_size != 0) ? m_alloc_size * std::ceil((double)n / m_alloc_size) : n;

                if (m_alloc_size != 0 && n < size() * 2 && n / m_alloc_size < 2)
                {
                    new_allocate_size = size() * 2;// std::ceil((double)n / m_alloc_size );
                }
                else if (m_alloc_size != 0 && n / m_alloc_size < 2)
                    new_allocate_size = m_alloc_size * 2/* std::ceil((double)n / m_alloc_size )*/;
                else
                    new_allocate_size = n;